# Functions to run the TMB stock recruitment  models
#===============================================
#Structure of the code copied from the sdmTMB package :
#https://github.com/pbs-assess/sdmTMB


#' Simple Ricker model estimated with TMB
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' 
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param tmb_map optional, mapping list indicating if parameters should be estimated of fixed. 
#' Default is all parameters are estimated
#' 
#' @returns a list containing several model outputs:
#' * alpha - MLE estimates for the alpha parameter vector
#' * beta - MLE estimates for the beta parameter 
#' * sigobs - MLE estimates for the observation error sigma         
#' * model - opt object, generated by the `stats::nlminb()`  
#' * tmb_data - data provided to TMB,
#' * tmb_params - parameter intial guesses,
#' * tmb_map - mapping indicating which parameters should be fixed or estimated,
#' * tmb_obj - obj object, generated by the `TMB::MakeADFun()` 
#' * gradients - final convergence gradient
#' * bad_eig - eigen value
#' * call - original function call
#' * sd_report - MLE estimates and sdt Error estimates for main parameter estimates
#' * class - name of cpp model
#' 
#' @importFrom stats nlminb 
#' 
#' @export
#' 
#' @examples
#' data(harck)
#' rickerTMB(data=harck)
#' 
rickerTMB <- function(data,  silent = FALSE, control = TMBcontrol(),  tmb_map = list()) {

  #===================================
  #prepare TMB input and options
  #===================================
  tmb_data <- list(
    obs_S = data$S,
    obs_logRS = data$logRS
  )

  initlm<-lm(logRS~S, data=data)

  tmb_params <- list(
    alpha   = initlm$coefficients[[1]],
    logbeta = ifelse(initlm$coefficients[[2]]<0,1e-08,log(-initlm$coefficients[[2]])),
    logsigobs = log(1)
  )

  #to be implemented

  tmb_random <- NULL

  #===================================
  # TMB fit
  #===================================

  tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_simple", silent = silent)
  
  tmb_opt <- stats::nlminb(
    start = tmb_obj$par, objective = tmb_obj$fn, gradient = tmb_obj$gr,
    control = control)
  
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)

  #todo add alpha, beta and sigma parameter esitimates

  structure(list(
    alpha    = tmb_obj$report()$alpha,
    beta     = tmb_obj$report()$beta,
    sig      = tmb_obj$report()$sigobs,
    model      = tmb_opt,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report),
    class      = "Ricker_simple")

}




#' Ricker model with random walk in alpha parameter with TMB
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' 
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param ini_param Optional. A list with initial parameter guesses. The list should contain: alphao (a number),
#' logbeta (a number), logsigobs (a number), logsiga (a number), and alpha ( a vector with the same length as the data). 
#' @param tmb_map optional, mapping list indicating if parameters should be estimated of fixed. 
#' Default is all parameters are estimated
#' 
#' 
#' 
#' @returns a list containing several model outputs:
#' * alpha - MLE estimates for the alpha parameter vector
#' * beta - MLE estimates for the beta parameter 
#' * sig - MLE estimates for the observation error sigma     
#' * siga - MLE estimates for the process error (variation in alpha) sigma    
#' * model - opt object, generated by the `stats::nlminb()`  
#' * tmb_data - data provided to TMB,
#' * tmb_params - parameter intial guesses,
#' * tmb_map - mapping indicating which parameters should be fixed or estimated,
#' * tmb_obj - obj object, generated by the `TMB::MakeADFun()` 
#' * gradients - final convergence gradient
#' * bad_eig - eigen value
#' * call - original function call
#' * sd_report - MLE estimates and sdt Error estimates for main parameter estimates
#' * class - name of cpp model
#' 
#' 
#' @export
#' @examples 
#' data(harck)
#' ricker_rwa_TMB(data=harck)
#' 
#' 
ricker_rwa_TMB <- function(data,  silent = FALSE, control = TMBcontrol(), ini_param=NULL, tmb_map = list()) {

  #===================================
  #prepare TMB input and options
  #===================================
  tmb_data <- list(
    obs_S = data$S,
    obs_logRS = data$logRS
  )

  

  if(is.null(ini_param)){
     initlm<-lm(logRS~S, data=data)
     tmb_params <- list(alphao   = initlm$coefficients[[1]],
                   logbeta = ifelse(initlm$coefficients[[2]]>0,log(1e-08),log(-initlm$coefficients[[2]])),
                   logsigobs = log(.5),
                   logsiga = log(.5),
                   alpha = rep(1,length(tmb_data$obs_S))
     )

  }else{
    tmb_params <-ini_param
  }

  
  tmb_random <- "alpha"

  #===================================
  # TMB fit
  #===================================

  tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_tva", silent = silent)
  
  tmb_opt <- stats::nlminb(
    start = tmb_obj$par, objective = tmb_obj$fn, gradient = tmb_obj$gr,
    control = control,
    lower = c(0,-20,log(0.01),log(0.01)), upper = c(20,-4,log(2),log(2)))
  
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)

  #todo add alpha, beta and sigma parameter esitimates

  structure(list(
    alpha    = tmb_obj$report()$alpha,
    beta     = tmb_obj$report()$beta,
    sig      = tmb_obj$report()$sigobs,
    siga      = tmb_obj$report()$siga,
    model      = tmb_opt,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_random = tmb_random,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report),
    class      = "Ricker_tva")

}





#' Ricker model with random walk in log(beta) parameter with TMB
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' 
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param ini_param Optional. A list with initial parameter guesses. The list should contain: logbetao (a number),
#' alpha (a number), logsigobs (a number), logsigb (a number), and logbeta ( a vector with the same length as the data). 
#' @param tmb_map optional, mapping list indicating if parameters should be estimated of fixed. 
#' Default is all parameters are estimated
#' 
#' 
#' 
#' @returns a list containing several model outputs:
#' * alpha - MLE estimates for the alpha parameter 
#' * beta - MLE estimates for the beta parameter vector
#' * sig - MLE estimates for the observation error sigma     
#' * sigb - MLE estimates for the process error (variation in log(beta)) sigma    
#' * model - opt object, generated by the `stats::nlminb()`  
#' * tmb_data - data provided to TMB,
#' * tmb_params - parameter intial guesses,
#' * tmb_map - mapping indicating which parameters should be fixed or estimated,
#' * tmb_obj - obj object, generated by the `TMB::MakeADFun()` 
#' * gradients - final convergence gradient
#' * bad_eig - eigen value
#' * call - original function call
#' * sd_report - MLE estimates and sdt Error estimates for main parameter estimates
#' * class - name of cpp model
#' 
#' 
#' @export
#' @examples 
#' data(harck)
#' ricker_rwb_TMB(data=harck)
#' 
ricker_rwb_TMB <- function(data,  silent = FALSE, control = TMBcontrol(), ini_param=NULL, tmb_map = list()) {

  #===================================
  #prepare TMB input and options
  #===================================
  tmb_data <- list(
    obs_S = data$S,
    obs_logRS = data$logRS
  )

  

  if(is.null(ini_param)){
     initlm<-lm(logRS~S, data=data)
     tmb_params <- list(logbetao = ifelse(initlm$coefficients[[2]]>0,log(1e-06),log(-initlm$coefficients[[2]])),
                        alpha   = initlm$coefficients[[1]],                 
                        logsigobs = log(.5),
                        logsigb = log(.5),
                        logbeta=log(rep(ifelse(initlm$coefficients[[2]]>0,log(1e-06),-initlm$coefficients[[2]]),length(data$S)))
                  
     )

  }else{
    tmb_params <-ini_param
  }

  
  tmb_random <- "logbeta"

  #===================================
  # TMB fit
  #===================================

  tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_tvlogb", silent = silent)
  
  tmb_opt <- stats::nlminb(
    start = tmb_obj$par, objective = tmb_obj$fn, gradient = tmb_obj$gr,
    control = control,
    lower = c(-20,0.1,log(0.01),log(0.01)), upper = c(-4,20,log(2),log(2)))
  
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)

  #todo add alpha, beta and sigma parameter esitimates

  structure(list(
    alpha    = tmb_obj$report()$alpha,
    beta     = tmb_obj$report()$beta,
    sig      = tmb_obj$report()$sigobs,
    sigb      = tmb_obj$report()$sigb,
    model      = tmb_opt,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_random = tmb_random,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report),
    class      = "Ricker_tvb")

}





#' Ricker model with random walk in log(beta) parameter with TMB
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' 
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param ini_param Optional. A list with initial parameter guesses. The list should contain: logbetao (a number),
#' alphao (a number), logsigobs (a number), logsiga (a number), logsigb (a number), 
#' alpha ( a vector with the same length as the data) and logbeta ( a vector with the same length as the data). 
#' @param tmb_map optional, mapping list indicating if parameters should be estimated of fixed. 
#' Default is all parameters are estimated
#' 
#' 
#' 
#' @returns a list containing several model outputs:
#' * alpha - MLE estimates for the alpha parameter vector
#' * beta - MLE estimates for the beta parameter vector
#' * sig - MLE estimates for the observation error sigma  
#' * siga - MLE estimates for the process error (variation in alpha) sigma     
#' * sigb - MLE estimates for the process error (variation in log(beta)) sigma    
#' * model - opt object, generated by the `stats::nlminb()`  
#' * tmb_data - data provided to TMB,
#' * tmb_params - parameter intial guesses,
#' * tmb_map - mapping indicating which parameters should be fixed or estimated,
#' * tmb_obj - obj object, generated by the `TMB::MakeADFun()` 
#' * gradients - final convergence gradient
#' * bad_eig - eigen value
#' * call - original function call
#' * sd_report - MLE estimates and sdt Error estimates for main parameter estimates
#' * class - name of cpp model
#' 
#' 
#' @export
#' @examples 
#' data(harck)
#' ricker_rwb_TMB(data=harck)
#' 
ricker_rwab_TMB <- function(data,  silent = FALSE, control = TMBcontrol(), ini_param=NULL, tmb_map = list()) {

  #===================================
  #prepare TMB input and options
  #===================================
  tmb_data <- list(
    obs_S = data$S,
    obs_logRS = data$logRS
  )

  

  if(is.null(ini_param)){
     initlm<-lm(logRS~S, data=data)
     tmb_params <- list(logbetao = ifelse(initlm$coefficients[[2]]>0,log(1e-06),log(-initlm$coefficients[[2]])),
                        alphao   = initlm$coefficients[[1]],                 
                        logsigobs = log(.5),
                        logsiga = log(.5),
                        logsigb = log(.5),
                        alpha = rep(initlm$coefficients[[1]],length(tmb_data$obs_S)),
                        logbeta=log(rep(ifelse(initlm$coefficients[[2]]>0,log(1e-06),-initlm$coefficients[[2]]),length(data$S)))
                  
     )

  }else{
    tmb_params <-ini_param
  }

  
  tmb_random <- c("logbeta", "alpha")

  #===================================
  # TMB fit
  #===================================

  tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_tva_tvb", silent = silent)
  
  tmb_opt <- stats::nlminb(
    start = tmb_obj$par, objective = tmb_obj$fn, gradient = tmb_obj$gr,
    control = control,
    lower = c(-20,0.1,log(0.01),log(0.01)), upper = c(-4,20,log(2),log(2)))
  
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)

  #todo add alpha, beta and sigma parameter esitimates

  structure(list(
    alpha    = tmb_obj$report()$alpha,
    beta     = tmb_obj$report()$beta,
    sig      = tmb_obj$report()$sigobs,
    siga      = tmb_obj$report()$sigb,
    sigb      = tmb_obj$report()$sigb,
    model      = tmb_opt,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_random = tmb_random,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report),
    class      = "Ricker_tva_tvb")

}







#' Ricker hidden markov model with regime shiftts for alpha and beta. 
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' @param k_regime Number of regimes to be considered
#' @param alpha_limits vector containing two values: upper and lower limit for alpha parameters. default is c(0,20)
#' @param beta_upper upper limit for beta parameter. default is 1
#' @param sigma_upper upper limit for beta parameter. default is 2
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param ini_param Optional. A list with initial parameter guesses. The list should contain: lalpha (vector of length k_regime),
#' lbeta (vector of length k_regime), lsigma (vector of length k_regime), pi1_tran (vector of length k_regime-1), 
#' and qij_tran (matrix with nrow=k_regime, and ncol=k_regime-1). Keep in mind that the main
#' parameters (alpha, beta and sigma) are transformed with a logistic function to account for the custom upper and lower values.   
#' 
#' @details This model was published in Tang et al. 2021 Identification of recruitment regime shifts with a hidden Markov stock-recruitment model. 
#' The code for this model was a contribution by Xiaozhuo Tang. 
#' 
#' @returns a list containing several model outputs:
#' * alpha - MLE estimates for the alpha parameter vector
#' * beta - MLE estimates for the beta parameter 
#' * sig  - MLE estimates for the observation error sigma     
#' * siga  - MLE estimates for the process error (variation in alpha) sigma    
#' * model - opt object, generated by the `TMB::MakeADFun()`   
#' * tmb_data - data provided to TMB,
#' * tmb_params = parameter intial guesses,
#' * tmb_map    = mapping indicating which parameters should be fixed or estimated,
#' * tmb_random = tmb_random,
#' * tmb_obj    = tmb_obj,
#' * gradients  = conv$final_grads,
#' * bad_eig    = conv$bad_eig,
#' * call       = match.call(expand.dots = TRUE),
#' * sd_report  = sd_report),
#' * class      = "Ricker_tva"
#' 
#'  @references{
#'   \insertRef{tangIdentificationRecruitmentRegime2021}{samEst}
#' }
#' 
#' @export
#' @examples 
#' data(harck)
#' ricker_HMM_TMB(data=harck)
ricker_HMM_TMB <- function(data, k_regime=2, alpha_limits=c(0,20), beta_upper=.1, sigma_upper=2, 
  silent = FALSE, control = TMBcontrol(), ini_param=NULL, tmb_map = list()) {

  #===================================
  #prepare TMB input and options
  #===================================
  
  tmb_data<-list(yt=data$logRS,
  st=data$S, 
  alpha_u= alpha_limits[2],
  alpha_l=alpha_limits[1],
  beta_u=beta_upper,
  sigma_u = sigma_upper
  )  

  if(is.null(ini_param)){
    initlm<-lm(logRS~S, data=data)
    
    tmb_params <- list( 
         
        lalpha = -(1:k_regime+1),
         lbeta = rep(log(1/max(data$S))+1,k_regime),
         lsigma = rep(log(1),k_regime),
         pi1_tran = rep(0,k_regime-1),
         qij_tran = matrix(0,nrow=k_regime,ncol=k_regime-1)          
       )  

  }else{
    tmb_params <-ini_param
  }

 


  #===================================
  # TMB fit
  #===================================

  tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
       DLL = "SR_HMM", silent = silent)
  
  tmb_opt <- stats::nlminb(
    start = tmb_obj$par, objective = tmb_obj$fn, gradient = tmb_obj$gr,
    control = control)#,
    #lower = c(-5,-18,log(0.01),log(0.01)), upper = c(20,-4,log(2),log(2))))
  
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)

  #todo add alpha, beta and sigma parameter esitimates

  structure(list(
    alpha    = tmb_obj$report()$alpha,
    beta     = tmb_obj$report()$beta,
    sigma      = tmb_obj$report()$sigma,
    pi1      = tmb_obj$report()$pi1,
    qij      = tmb_obj$report()$qij,
    regime =  apply(tmb_obj$report()$r_pred, 2,which.max),
    model      = tmb_opt,
    data       = data,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report),
    class      = "SR_HMM")

}







#' Optimization control options. Copied from sdmTMB
#'
#' Any arguments to pass to [stats::nlminb()].
#'
#' @param eval.max Maximum number of evaluations of the objective function
#'   allowed.
#' @param iter.max Maximum number of iterations allowed.
#' @param ... Anything else. See the 'Control parameters' section of
#'   [stats::nlminb()].
#'
#' @export
TMBcontrol <- function(eval.max = 1e4, iter.max = 1e4, ...) {
  list(eval.max = eval.max, iter.max = iter.max, ...)
}





#' get TMB convergence diagnostics taken from sdmTMB
#'
#' @param sd_report A TMB sd report object
#' @export
get_convergence_diagnostics <- function(sd_report) {
  final_grads <- sd_report$gradient.fixed
  bad_eig <- FALSE
  if (!is.null(sd_report$pdHess)) {
    if (!sd_report$pdHess) {
      warning("The model may not have converged: ",
        "non-positive-definite Hessian matrix.", call. = FALSE)
    } else {
      eigval <- try(1 / eigen(sd_report$cov.fixed)$values, silent = TRUE)
      if (is(eigval, "try-error") || (min(eigval) < .Machine$double.eps * 10)) {
        warning("The model may not have converged: ",
          "extreme or very small eigen values detected.", call. = FALSE)
        bad_eig <- TRUE
      }
      if (any(final_grads > 0.01))
        warning("The model may not have converged. ",
          "Maximum final gradient: ", max(final_grads), ".", call. = FALSE)
    }
  }
  invisible(list(final_grads = final_grads, bad_eig = bad_eig))
}



#==============================================================
#Dummy function

#' Roxygen commands
#'
#' This is a dummy function to hold the useDynLib roxygen tag.
#' This tag will populate the namespace with compiled c++ functions upon package install.
#'
#' @useDynLib Ricker_simple
#' @useDynLib Ricker_tva
#' @useDynLib SR_HMM
#' @useDynLib Ricker_tvlogb
#' @useDynLib Ricker_tva_tvb
#' 
#'
dummy <- function(){
  return(NULL)
}

# END
#***********************************************************************************
