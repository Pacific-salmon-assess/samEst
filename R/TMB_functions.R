# Functions to run the TMB stock recruitment  models
#===============================================
#Structure of the code copied from the sdmTMB package :
#https://github.com/pbs-assess/sdmTMB


#' Simple Ricker model estimated with TMB
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' 
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param tmb_map optional, mapping list indicating if parameters should be estimated of fixed. 
#' Default is all parameters are estimated
#' @param AC Logical. Are residuals autocorrelated? Default is FALSE
#' @param priors Integer, 1 priors are included in estimation model, 0 priors are not included.
#'  See details for priors documentation
#' 
#' @details Priors: Weakly informative priors are included for the main parameterst of the model:
#' alpha ~ N(0,2.5)
#' logbeta ~ N(-12,3)
#' sigobs ~ gamma(2,1/3) 
#' 
#' 
#' @returns a list containing several model outputs:
#' * alpha - MLE estimates for the alpha parameter vector
#' * beta - MLE estimates for the beta parameter 
#' * sigobs - MLE estimates for the observation error sigma         
#' * model - opt object, generated by the `stats::nlminb()`  
#' * tmb_data - data provided to TMB,
#' * tmb_params - parameter intial guesses,
#' * tmb_map - mapping indicating which parameters should be fixed or estimated,
#' * tmb_obj - obj object, generated by the `TMB::MakeADFun()` 
#' * gradients - final convergence gradient
#' * bad_eig - eigen value
#' * call - original function call
#' * sd_report - MLE estimates and sdt Error estimates for main parameter estimates
#' * class - name of cpp model
#' 
#' @importFrom stats nlminb 
#' 
#' @export
#' 
#' @examples
#' data(harck)
#' rickerTMB(data=harck)
#' 
ricker_TMB <- function(data,  silent = FALSE, control = TMBcontrol(),  tmb_map = list(),
 AC=FALSE, priors=1) {

  
  tmb_data <- list(
    obs_S = data$S,
    obs_logRS = data$logRS,
    priors=priors
  )
  
  magS <- log10_ceiling(max(data$S))
  initlm <- lm(logRS~S, data=data)
  tmb_random <- NULL

  if(!AC){
    tmb_params <- list(
      alpha   = initlm$coefficients[[1]],
      logbeta = ifelse(initlm$coefficients[[2]]>0,log(magS),log(-initlm$coefficients[[2]])),
      logsigobs = log(1)
    )

    tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_simple", silent = silent)
  
  }else{
    tmb_params <- list(
      alpha   = initlm$coefficients[[1]],
      logbeta = ifelse(initlm$coefficients[[2]]>0,log(magS),log(-initlm$coefficients[[2]])),
      logsigobs = log(1),
      rho=0
    )

    tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_autocorr", silent = silent)
  

  }

  tmb_opt <- stats::nlminb(
      start = tmb_obj$par, objective = tmb_obj$fn, gradient = tmb_obj$gr,
      control = control)
  
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)
  

  
  structure(list(
    alpha    = tmb_obj$report()$alpha,
    beta     = tmb_obj$report()$beta,
    Smax     = tmb_obj$report()$Smax,
    sig      = tmb_obj$report()$sigobs,
    Smsy      = tmb_obj$report()$Smsy,
    umsy      = tmb_obj$report()$umsy,
    sigar    = ifelse(AC,tmb_obj$report()$sigAR,NA),
    rho      = ifelse(AC,tmb_obj$report()$rhoo,NA),
    residuals= tmb_obj$report()$residuals,
    model      = tmb_opt,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    conv_problem= conv$conv_problem,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report),
    class      = ifelse(AC,"Ricker_autocorr","Ricker_simple"))

}




#' Ricker model with random walk in alpha parameter with TMB
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' @param tv.par Which parameters should vary? Either productivity (intercept, a), capacity (slope, b) or both parameters
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param ini_param Optional. A list with initial parameter guesses. The list should contain: alphao (a number),
#' logbeta (a number), logsigobs (a number), logsiga (a number), and alpha ( a vector with the same length as the data). 
#' @param tmb_map optional, mapping list indicating if parameters should be estimated of fixed. 
#' Default is all parameters are estimated
#' @param priors Integer, 1 priors are included in estimation model, 0 priors are not included.
#'  See details for priors documentation
#' 
#' @details Priors: Weakly informative priors are included for the main parameterst of the model:
#' alpha ~ N(0,2.5)
#' logbeta ~ N(-12,3)
#' sigobs ~ gamma(2,1/3)
#' siga ~ gamma(2,1/3) 
#' sigb ~ gamma(2,1/3)  
#' 
#' 
#' @returns a list containing several model outputs:
#' * alpha - MLE estimates for the alpha parameter vector
#' * beta - MLE estimates for the beta parameter 
#' * sig - MLE estimates for the observation error standard deviation     
#' * siga - MLE estimates for the process error (variation in alpha) standard deviation
#' * sigb - MLE estimates for the process error (variation in beta) standard deviation   
#' * model - opt object, generated by the `stats::nlminb()`  
#' * tmb_data - data provided to TMB,
#' * tmb_params - parameter intial guesses,
#' * tmb_map - mapping indicating which parameters should be fixed or estimated,
#' * tmb_obj - obj object, generated by the `TMB::MakeADFun()` 
#' * gradients - final convergence gradient
#' * bad_eig - eigen value
#' * call - original function call
#' * sd_report - MLE estimates and sdt Error estimates for main parameter estimates
#' * class - name of cpp model
#' 
#' 
#' @export
#' @examples 
#' data(harck)
#' ricker_rwa_TMB(data=harck)
#' 
#' 
ricker_rw_TMB <- function(data, tv.par=c('a','b','both'), silent = FALSE, 
  control = TMBcontrol(), ini_param=NULL, tmb_map = list(), priors=1) {

  #===================================
  #prepare TMB input and options
  #===================================
  tmb_data <- list(
    obs_S = data$S,
    obs_logRS = data$logRS,
    priors=priors
  )

  if(is.null(ini_param)){
    magS <- log10_ceiling(max(data$S))
    initlm<-lm(logRS~S, data=data)
  }


  if(tv.par=="a"){

    if(is.null(ini_param)){
      tmb_params <- list(alphao   = initlm$coefficients[[1]],
                   logbeta = ifelse(initlm$coefficients[[2]]>0,log(magS),log(-initlm$coefficients[[2]])),
                   logsigobs = log(.5),
                   logsiga = log(.5),
                   alpha = rep(1,length(tmb_data$obs_S))
      )
    }else{
      tmb_params <-ini_param
    }
    tmb_random <- "alpha"
    tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_tva", silent = silent)

    lowlimit <- c(0,-20,log(0.01),log(0.01))
    hightlimit <- c(20,-4,log(2),log(2))

   clss <- "Ricker_tva"
  }else if(tv.par=="b"){

    if(is.null(ini_param)){
     
      tmb_params <- list(logbetao = ifelse(initlm$coefficients[[2]]>0,log(1/max(data$S)),log(-initlm$coefficients[[2]])),
                        alpha   = max(initlm$coefficients[[1]],.5),                 
                        logsigobs = log(.5),
                        logsigb = log(.2),
                        logbeta=rep(ifelse(initlm$coefficients[[2]]>0,log(1/max(data$S)),log(-initlm$coefficients[[2]])),length(data$S))                  
      )
    }else{
      tmb_params <-ini_param
    }

    tmb_random <- "logbeta"

    tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_tvlogb", silent = silent)

    lowlimit <- c(-20,0.1,log(0.01),log(0.01))
    hightlimit <- c(-4,20,log(2),log(2))

    clss <- "Ricker_tvlogb"

  }else if(tv.par=="both"){
    
    if(is.null(ini_param)){    
      tmb_params <- list(logbetao = ifelse(initlm$coefficients[[2]]>0,log(magS),log(-initlm$coefficients[[2]])),
                        alphao   = max(initlm$coefficients[[1]],.5),                 
                        logsigobs = log(.5),
                        logsiga = log(.5),
                        logsigb = log(.5),
                        alpha = rep(initlm$coefficients[[1]],length(tmb_data$obs_S)),
                        logbeta=log(rep(ifelse(initlm$coefficients[[2]]>0,log(1e-06),-initlm$coefficients[[2]]),length(data$S)))
                  
     )

    }else{
      tmb_params <-ini_param
    }
    tmb_random <- c("logbeta", "alpha")

    tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      random = tmb_random, DLL = "Ricker_tva_tvb", silent = silent)
  
    lowlimit <- c(-20,0.1,log(0.01),log(0.01),log(0.01))
    hightlimit <- c(-4,20,log(2),log(2),log(2))
    
    clss <- "Ricker_tva_tvb"

  }else{
    stop(paste("tv.par",tv.par,"not recognized."))
  }
 

  #===================================
  # TMB fit
  #===================================

 
  
  tmb_opt <- stats::nlminb(
    start = tmb_obj$par, 
    objective = tmb_obj$fn, 
    gradient = tmb_obj$gr,
    control = control,
    lower = lowlimit, 
    upper = hightlimit)
  
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)

  #todo add alpha, beta and sigma parameter esitimates

  structure(list(
    alpha    = tmb_obj$report()$alpha,
    beta     = tmb_obj$report()$beta,
    Smax     = tmb_obj$report()$Smax,
    sig      = tmb_obj$report()$sigobs,
    Smsy      = tmb_obj$report()$Smsy,
    umsy      = tmb_obj$report()$umsy,
    siga      = ifelse(tv.par=="a"|tv.par=="both",tmb_obj$report()$siga,NA),
    sigb      = ifelse(tv.par=="b"|tv.par=="both",tmb_obj$report()$sigb,NA),
    model      = tmb_opt,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_random = tmb_random,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    conv_problem= conv$conv_problem,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report),
    class      = clss)

}





#' Ricker hidden markov model with regime shiftts for alpha and beta. 
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' @param tv.par Which parameters should vary? Either productivity (intercept, a), capacity (slope, b) or both parameters
#' @param k_regime Number of regimes to be considered
#' @param alpha_limits vector containing two values: upper and lower limit for alpha parameters. default is c(0,20)
#' @param beta_upper upper limit for beta parameter. default is 1
#' @param sigma_upper upper limit for beta parameter. default is 2
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param ini_param Optional. A list with initial parameter guesses. The list should contain: lalpha (vector of length k_regime),
#' lbeta (vector of length k_regime), lsigma (vector of length k_regime), pi1_tran (vector of length k_regime-1), 
#' and qij_tran (matrix with nrow=k_regime, and ncol=k_regime-1). Keep in mind that the main
#' parameters (alpha, beta and sigma) are transformed with a logistic function to account for the custom upper and lower values.   
#' @param priors Integer, 1 priors are included in estimation model, 0 priors are not included.
#'  See details for priors documentation
#' 
#' 
#' 
#' @details This model was published in Tang et al. 2021 Identification of recruitment regime shifts with a hidden Markov stock-recruitment model. 
#' The code for this model was a contribution by Xiaozhuo Tang. 
#' 
#' Priors: Weakly informative priors are included for the main parameterst of the model:
#' alpha ~ N(0,2.5)
#' logbeta ~ N(-12,3)
#' sigobs ~ gamma(2,1/3)
#' qi ~ gamma(2,1/3) 
#' sigb ~ gamma(2,1/3)  
#' 
#' @returns a list containing several model outputs:
#' * alpha - MLE estimates for the alpha parameter vector
#' * beta - MLE estimates for the beta parameter 
#' * sig  - MLE estimates for the observation error sigma     
#' * pi  - MLE estimates for the initial state probabilities vector of length k_regime
#' * A  - MLE estimates for the transition probabilities, matrix (k_regime x k_regime)   
#' * model - opt object, generated by the `TMB::MakeADFun()`   
#' * tmb_data - data provided to TMB,
#' * tmb_params = parameter intial guesses,
#' * tmb_map    = mapping indicating which parameters should be fixed or estimated,
#' * tmb_random = tmb_random,
#' * tmb_obj    = tmb_obj,
#' * gradients  = conv$final_grads,
#' * bad_eig    = conv$bad_eig,
#' * call       = match.call(expand.dots = TRUE),
#' * sd_report  = sd_report),
#' * class      = "Ricker_tva"
#' 
#'  @references{
#'   \insertRef{tangIdentificationRecruitmentRegime2021}{samEst}
#' }
#' 
#' @export
#' @examples 
#' data(harck)
#' ricker_HMM_TMB(data=harck)
ricker_hmm_TMB <- function(data, tv.par=c('a','b','both'), k_regime=2, alpha_limits=c(0,20), 
  beta_upper=.1, sigma_upper=2, silent = FALSE, control = TMBcontrol(), ini_param=NULL, 
  tmb_map = list(), priors=1) {

  #===================================
  #prepare TMB input and options
  #===================================
  
  tmb_data<-list(yt=data$logRS,
  st=data$S, 
  alpha_u= alpha_limits[2],
  alpha_l=alpha_limits[1],
  beta_u=beta_upper,
  sigma_u = sigma_upper,
  alpha_dirichlet=rep(1,k_regime),
  priors=priors  
  )

  if(is.null(ini_param)){
    magS <- 1/log10_ceiling(max(data$S))
    initlm<-lm(logRS~S, data=data)
    bguess<-ifelse(initlm$coefficients[[2]]>0,(magS),initlm$coefficients[[2]])
  }

  if(tv.par == "a"){
    if(is.null(ini_param)){
    
      tmb_params <- list(        
          lalpha = rep(find_linit(alpha_limits[2],alpha_limits[1],max(initlm$coefficients[[1]],.5)),
            k_regime),
          lbeta = find_linit(beta_upper,0,-bguess),
          lsigma = find_linit(sigma_upper,0,.1),
          pi1_tran = rep(0.5,k_regime-1),
          qij_tran = matrix(0.1,nrow=k_regime,ncol=k_regime-1)          
      )  
    
    }else{
      tmb_params <- ini_param
    }

    tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      DLL = "SR_HMM_a", silent = silent)
  
    clss <- "SR_HMM_a"

  }else if(tv.par=="b"){
  
    if(is.null(ini_param)){      
      tmb_params <- list(        
          lalpha = find_linit(alpha_limits[2],alpha_limits[1],max(initlm$coefficients[[1]],.5)),
          lbeta = rep(find_linit(beta_upper,0,-bguess),k_regime),
          lsigma = find_linit(sigma_upper,0,.1),
          pi1_tran = rep(0.5,k_regime-1),
          qij_tran = matrix(0.5,nrow=k_regime,ncol=k_regime-1)          
      )      
    }else{
      tmb_params <-ini_param
    }
 
    tmb_obj <- TMB::MakeADFun(
      data = tmb_data, parameters = tmb_params, map = tmb_map,
      DLL = "SR_HMM_b", silent = silent)
    
    clss <- "SR_HMM_b"

  }else if(tv.par=="both"){
    if(is.null(ini_param)){
      tmb_params <- list(        
        lalpha = rep(find_linit(alpha_limits[2],alpha_limits[1],max(initlm$coefficients[[1]],.5)),
          k_regime),
        lbeta = rep(find_linit(beta_upper,0,-bguess),k_regime),
        lsigma = find_linit(sigma_upper,0,.1),
        pi1_tran = rep(0.5,k_regime-1),
        qij_tran = matrix(0.1,nrow=k_regime,ncol=k_regime-1)          
      )

    }else{
      tmb_params <-ini_param
    }

    tmb_obj <- TMB::MakeADFun(data = tmb_data, parameters = tmb_params, map = tmb_map,
      DLL = "SR_HMM", silent = silent)
    
    clss <- "SR_HMM"
  }else{
    stop(paste("tv.par",tv.par,"not recognized."))
  }  

  
  tmb_opt <- stats::nlminb(
    start = tmb_obj$par, objective = tmb_obj$fn, gradient = tmb_obj$gr,
    control = control)#,
    
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)


  structure(list(
    alpha    = tmb_obj$report()$alpha,
    beta     = tmb_obj$report()$beta,
    sigma      = tmb_obj$report()$sigma,
    pi1      = tmb_obj$report()$pi1,
    qij      = tmb_obj$report()$qij,
    Smsy      = tmb_obj$report()$Smsy,
    Smax      = tmb_obj$report()$Smax,
    umsy      = tmb_obj$report()$umsy,
    probregime =  tmb_obj$report()$r_pred,
    regime =  apply(tmb_obj$report()$r_pred, 2,which.max),
    model      = tmb_opt,
    data       = data,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    conv_problem= conv$conv_problem,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report,
    class      = clss)
    )

}





#' Ricker model with time-varying alpha estimated with Kalman Filter
#'
#' @param data A list or data frame containing Spawners (S) and log(Recruits/Spawners) (logRS) time series. 
#' 
#' @param silent Logical Silent or optimization details? default is FALSE
#' @param control output from TMBcontrol() function, to be passed to nlminb()
#' @param tmb_map optional, mapping list indicating if parameters should be estimated of fixed. 
#' Default is all parameters are estimated
#' @param fullLL Should full likelihood function be used, should be used if comparing wth AIC.Default is FALSE
#' 
#' 
#' @returns a list containing several model outputs:
#' * alpha - KF estimates for the alpha parameter vector
#' * beta - KF  estimates for the beta parameter 
#' * sigobs - MLE estimates for the observation error sigma         
#' * model - opt object, generated by the `stats::nlminb()`  
#' * tmb_data - data provided to TMB,
#' * tmb_params - parameter intial guesses,
#' * tmb_map - mapping indicating which parameters should be fixed or estimated,
#' * tmb_obj - obj object, generated by the `TMB::MakeADFun()` 
#' * gradients - final convergence gradient
#' * bad_eig - eigen value
#' * call - original function call
#' * sd_report - MLE estimates and sdt Error estimates for main parameter estimates
#' * class - name of cpp model
#' 
#' @importFrom stats nlminb 
#' 
#' @export
#' 
#' @examples
#' data(harck)
#' rickerTMB(data=harck)
#' 
ricker_kf_TMB <- function(data,  silent = FALSE, control = TMBcontrol(),  tmb_map = list(), fullLL=FALSE) {

  
  tmb_data <- list(
    x = data$S,
    y = data$logRS
  )
  
  magS <- log10_ceiling(max(data$S))
  initlm <- lm(logRS~S, data=data)
  tmb_random <- NULL

  tmb_params <- list(
    initmeana   = initlm$coefficients[[1]],
    b = ifelse(initlm$coefficients[[2]]>0,1/magS,-initlm$coefficients[[2]]),
    logsige     = log(1),
    logsigw     = log(1)
  )

  if(fullLL){
     tmb_obj <- TMB::MakeADFun(
    data = tmb_data, parameters = tmb_params, map = tmb_map,
    random = tmb_random, DLL = "Rickerkf_fullLL", silent = silent)
   }else{
     tmb_obj <- TMB::MakeADFun(
    data = tmb_data, parameters = tmb_params, map = tmb_map,
    random = tmb_random, DLL = "Rickerkf", silent = silent)
   }
 
  


  tmb_opt <- stats::nlminb(
      start = tmb_obj$par, objective = tmb_obj$fn, gradient = tmb_obj$gr,
      control = control)
  
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)
  

  
  structure(list(
    alpha    = tmb_obj$report()$smoothemeana,
    beta     = -tmb_obj$report()$b,
    sigobs    = tmb_obj$report()$sige,
    siga      = tmb_obj$report()$sigw,
    Smsy      = tmb_obj$report()$Smsy,
    umsy      = tmb_obj$report()$umsy,
    model      = tmb_opt,
    tmb_data   = tmb_data,
    tmb_params = tmb_params,
    tmb_map    = tmb_map,
    tmb_obj    = tmb_obj,
    gradients  = conv$final_grads,
    bad_eig    = conv$bad_eig,
    conv_problem = conv$conv_problem,
    call       = match.call(expand.dots = TRUE),
    sd_report  = sd_report,
    class      = ifelse(fullLL,"Rickerkf_fullLL","Rickerkf")))

}






#' Optimization control options. Copied from sdmTMB
#'
#' Any arguments to pass to [stats::nlminb()].
#'
#' @param eval.max Maximum number of evaluations of the objective function
#'   allowed.
#' @param iter.max Maximum number of iterations allowed.
#' @param ... Anything else. See the 'Control parameters' section of
#'   [stats::nlminb()].
#'
#' @export
TMBcontrol <- function(eval.max = 1e4, iter.max = 1e4, ...) {
  list(eval.max = eval.max, iter.max = iter.max, ...)
}





#' get TMB convergence diagnostics taken from sdmTMB
#'
#' @param sd_report A TMB sd report object
#' @export
get_convergence_diagnostics <- function(sd_report) {
  final_grads <- sd_report$gradient.fixed
  bad_eig <- FALSE
  conv_problem<-FALSE
  if (!is.null(sd_report$pdHess)) {
    if (!sd_report$pdHess) {
      warning("The model may not have converged: ",
        "non-positive-definite Hessian matrix.", call. = FALSE)
      conv_problem<-TRUE
    } else {
      eigval <- try(1 / eigen(sd_report$cov.fixed)$values, silent = TRUE)
      if (is(eigval, "try-error") || (min(eigval) < .Machine$double.eps * 10)) {
        warning("The model may not have converged: ",
          "extreme or very small eigen values detected.", call. = FALSE)
        bad_eig <- TRUE
        conv_problem<-TRUE
      }
      if (any(final_grads > 0.01)){
        warning("The model may not have converged. ",
          "Maximum final gradient: ", max(final_grads), ".", call. = FALSE)
        conv_problem<-TRUE
      }
    }
  }
  invisible(list(final_grads = final_grads, bad_eig = bad_eig, conv_problem = conv_problem))
}



#==============================================================
#Dummy function

#' Roxygen commands
#'
#' This is a dummy function to hold the useDynLib roxygen tag.
#' This tag will populate the namespace with compiled c++ functions upon package install.
#'
#' @useDynLib Ricker_simple
#' @useDynLib Ricker_autocorr
#' @useDynLib Ricker_tva
#' @useDynLib SR_HMM
#' @useDynLib Ricker_tvlogb
#' @useDynLib Ricker_tva_tvb
#' @useDynLib SR_HMM_a
#' @useDynLib SR_HMM_b
#' @useDynLib Rickerkf_fullLL
#' @useDynLib Rickerkf
#'
dummy <- function(){
  return(NULL)
}

# END
#***********************************************************************************
